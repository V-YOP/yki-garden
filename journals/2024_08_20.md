- #Docker compose #yaml 抽象重复配置
  collapsed:: true
	- yaml提供了语法，提供一种“引用”其他部分定义的变量的方式，可以用来做Docker Compose的配置抽象。该操作的语法和C的取指针和解引用相同，使用`&`定义引用，使用`*`去解引用。
	- ```yaml
	  # 这里的 'x-microservice-config' 无关紧要
	  # 但docker compose对顶层的变量有名称要求，这里以x-开头反正是能规避它
	  x-microservice-config: &microserviceShared
	        TZ: Asia/Shanghai
	        NACOS_HOST: 127.0.0.1
	        NACOS_PORT: 8848
	        MYSQL_HOST: 127.0.0.1
	        MYSQL_PWD: 123
	        # ...
	        
	  services:
	      some-service:
	        image: ...
	        environment:
	          # 这里的 <<: 猜测是一种“展平”语法，不纠结它
	          <<: *microserviceShared
	          OTHER_ENV: ...
	  ```
- Ubuntu 22.04 搭建[[Docker]]环境  #snippet/shell
  collapsed:: true
	- 参考 <https://blog.csdn.net/magic_ll/article/details/139985543> 和 [Ubuntu USTC Mirror help](https://mirrors.ustc.edu.cn/help/ubuntu.html)
	- ```sh
	  # 更换 APT 源
	  sudo sed -i 's@//.*archive.ubuntu.com@//mirrors.ustc.edu.cn@g' /etc/apt/sources.list
	  
	  # 安装可能缺失的依赖
	  sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common -y
	  
	  # 添加Docker GPG密钥并添加仓库
	  curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
	  sudo add-apt-repository  \
	  "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"
	  
	  # 安装docker
	  sudo apt install -y docker-ce docker-ce-cli containerd.io
	  
	  # 更换Docker源
	  sudo tee /etc/docker/daemon.json > /dev/null <<EOF
	  {
	      "registry-mirrors": [ "https://docker.ketches.cn" ]
	  }
	  EOF
	  
	  # 重启 Docker 以应用源
	  sudo systemctl restart docker
	  
	  # 测试能否拉取
	  sudo docker run --rm hello-world
	  ```
- [[Docker]] 移动docker数据位置（以腾出空间） #snippet/shell
  collapsed:: true
	- 执行此操作考虑删除所有容器，镜像和卷，否则现存的容器，以及使用这些镜像创建的容器可能会出现各种奇怪的权限问题。
	- ```sh
	  # 删除所有容器
	  docker stop $(docker ps -q)
	  docker rm $(docker ps -a -q)
	  
	  # 删除所有镜像和卷
	  docker system prune --all -f
	  docker volume prune --all -f
	  
	  
	  # 关闭docker
	  systemctl stop docker
	  
	  # 创建新Docker目录，假设是 /data 下，同步旧文件
	  mkdir -p /data/docker
	  
	  # 全新安装的docker不需要做同步
	  # rsync -aP /var/lib/docker/ /data/docker/
	  
	  # 编辑配置文件，重启
	  tee /etc/docker/daemon.json > /dev/null <<EOF
	  {
	  	"data-root": "/data/docker",
	      "registry-mirrors": [ "https://docker.ketches.cn" ]
	  }
	  EOF
	  systemctl start docker
	  
	  # 验证
	  docker info | grep "Docker Root Dir"
	  ```
- #MySQL 移动数据位置（以腾出空间）
  collapsed:: true
	- ```sh
	  systemctl stop mysql
	  
	  mkdir -p /data/mysql
	  chown mysql:mysql /data/mysql
	  chmod 750 /data/mysql
	  
	  rsync -av /var/lib/mysql/ /data/mysql/
	  chown -R mysql:mysql /data/mysql
	  
	  # 编辑 /etc/mysql/my.cnf，添加：
	  [mysqld]
	  datadir=/data/mysql
	  
	  # 编辑 AppArmor
	  vim /etc/apparmor.d/usr.sbin.mysqld
	  # 把 /var/lib/mysql 都替换成 /data/mysql
	  
	  # 刷新 AppArmor
	  apparmor_parser -r /etc/apparmor.d/usr.sbin.mysqld
	  
	  systemctl restart mysql
	  ```
- #MySQL 导出数据库
  collapsed:: true
	- ```sh
	  mysqldump \
	      -u root \
	      --password='abc' \
	      --single-transaction \
	      --quick \
	      --skip_add_locks \
	      --skip-lock-tables \
	      some_db    >  some_db.sql   
	  # 
	  #
	  #
	  ```
- #MySQL 导入数据
  collapsed:: true
	- ```sh
	  mysql \
	      -u root \
	      --password="" \
	      some_db < some_db.sql
	  ```
- #Docker [[redis]] 集群搭建
  collapsed:: true
	- docker compose：
		- ```yml
		    redis-node1:  # 服务名
		      image: redis:latest  # 使用的镜像
		      container_name: redis-node1 # docker启动的容器名
		      ports:  # 映射的端口 7001是redis server使用，17001是集群之间节点通信使用，都必须开放映射，如果不指定17001端口映射的话，创建集群的时候节点之间不能通信，集群会创建失败
		        - "7001:7001"
		        - "17001:17001"
		      volumes:  # 映射的容器卷
		        - ./redis-cluster/redis-cluster7001.conf:/usr/local/etc/redis/redis.conf
		        - ./redis-cluster/data:/data
		      command: bash -c "redis-server /usr/local/etc/redis/redis.conf"
		  
		    redis-node2:
		      image: redis:latest
		      container_name: redis-node2
		      ports:
		        - "7002:7002"
		        - "17002:17002"
		      volumes:
		        - ./redis-cluster/redis-cluster7002.conf:/usr/local/etc/redis/redis.conf
		        - ./redis-cluster/data:/data
		      command: redis-server /usr/local/etc/redis/redis.conf
		  
		    redis-node3:
		      image: redis:latest
		      container_name: redis-node3
		      ports:
		        - "7003:7003"
		        - "17003:17003"
		      volumes:
		        - ./redis-cluster/redis-cluster7003.conf:/usr/local/etc/redis/redis.conf
		        - ./redis-cluster/data:/data
		      command: redis-server /usr/local/etc/redis/redis.conf
		  ```
	- `redis.conf`（集群每个节点有自己的）：
		- ```
		  # 端口（7001 ~ 7006）
		  port 7001
		  # 可以连接的ip
		  bind 0.0.0.0
		  # 密码认证
		  requirepass Ldap12345
		  masterauth Ldap12345
		  # 开启保护模式
		  protected-mode yes
		  # 启动集群模式
		  cluster-enabled yes
		  # 配置文件名称（nodes7001.conf ~ nodes7006.conf）
		  cluster-config-file nodes7001.conf
		  # 节点超时时间
		  cluster-node-timeout 5000
		  # 当前节点ip
		  cluster-announce-ip 172.31.129.120
		  # 当前节点端口（7001 ~ 7006）
		  cluster-announce-port 7001
		  # 集群之间通信的端口号（17001 ~ 17006）
		  cluster-announce-bus-port 17001
		  # 启用AOF持久化
		  appendonly yes
		  ```
	- 随便进入其中一个redis容器，执行：
	- ```sh
	  redis-cli -a redis-password --cluster create \
	      127.0.0.1:7001 \
	      127.0.0.1:7002 \
	      127.0.0.1:7003
	  # 这里似乎是应当指定外部 IP？
	  ```
-