- 幸せになりたいな。
- # #trick #Java 关于 Jackson 对 enum 序列化反序列化
	- 对枚举，一个常见的需求就是用一个code进行序列化，反序列化，但**Jackson的默认行为是使用枚举名进行序列化、反序列化**。可以使用`@JsonValue`，`@JsonCreator`约束其序列化行为——**Jackson使用`@JsonValue`方法进行序列化，使用`@JsonCreator`方法进行反序列化**，只需要让它们读写code即可：
	- ```java
	  enum SomeEnum {
	    Just(1), Nothing(0),
	    ;
	    private final int code;
	    SomeEnum(int i) {
	      code = i;
	    }
	  
	    @JsonValue
	    public int getCode() {
	      return code;
	    }
	  
	    @JsonCreator
	    public static SomeEnum fromCode(int i) {
	      for (SomeEnum value : SomeEnum.values()) {
	        if (value.getCode() == i) {
	          return value;
	        }
	      }
	      throw new IllegalArgumentException("Unknown SomeEnum Code: " + i);
	    }
	  }
	  ```
- # #trick #Java 关于Mybatis对enum序列化反序列化
	- **Mybatis默认行为同样是按枚举名进行序列化、反序列化**。可以自定义TypeHandler（继承`EnumTypeHandler`）去处理相应枚举的序列化、反序列化。但这里需要让枚举实现一个父类去获取code字段。
	- ```java
	  // CodeEnum.java
	  package com.ruoyi.common.core.enums;
	  import com.fasterxml.jackson.annotation.JsonValue;
	  
	  /**
	   * 支持枚举使用 code 进行 json 序列化/反序列化和数据库序列化/反序列化
	   * <p/>
	   * <b>子类应当定义一个@JsonCreator标注的，根据code返回相应实例的静态方法以实现json的反序列化！</b>
	   */
	  public interface CodeEnum<T extends Enum<T>> {
	      @JsonValue
	      public int getCode();
	  }
	  
	  // 
	  ```