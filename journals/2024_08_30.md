# 关于 [[Python]] 的生成器（协程）的`yield`的心智模型
	- `yield`应当认为是**非原子的**，它是一个**两步**的操作：**向调用者返回一个值（或None）；暂停期待调用者的唤起**。在唤起之前，生成器中当前执行的代码始终是`yield XXX`，**协程在`yield`内部暂停**。
	- **调用者唤起协程时，会向协程传递特定的值或者异常，然后控制权交给协程去继续执行；倘若是传递特定的值，则该值会作为`yield`语句的返回值返回过来；倘若是传递异常，则异常会直接从`field`语句位置抛出**。
	- 唤起协程有三种方式——协程的`send`和`throw`方法，以及`next`函数：
		- `send`：传递给协程一个值，执行直到遇到下一个`yield`或完成执行，倘若是前者，返回下一个`yield`传过来的值。
		- `throw`：让协程在`yield`内部抛出异常，期待生成器的捕获，并继续执行（同`send`），使用生成器函数定义上下文管理器时内置库会使用该操作。
		- `next`：等价于`send(None)`。
	- 此外，刚创建的生成器不能执行`send(非None值)`，这是符合逻辑的——没有人去接受它。但能抛出异常……此时生成器无法捕获它，它会立刻被传播回调用者，很有趣的设计。
- # 关于 [[Python]] 的上下文管理器，以及contextlib.contextmanager的实现
	- 上下文管理器本质上就是，对 `with XXX （as f）`：把XXX的值赋给f，然后调用XXX的`__enter__`方法，执行with的代码体，待执行完后或者抛出异常时，执行XXX的`__exit__`方法。
-